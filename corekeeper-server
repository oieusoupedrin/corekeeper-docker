#!/bin/bash
# corekeeper-server starts the Corekeeper server
# binary either vanilla from /opt/corekeeper/server

# Include defaults and common functions
. /usr/local/etc/corekeeper/defaults
. /usr/local/etc/corekeeper/common

export SteamAppId=892970

corekeeper_server_pid=-1
timeout=29
kill_signal=TERM
password_args=(-password "$SERVER_PASS")
mod_name=none

cd "$corekeeper_install_path" || fatal "Could not cd $corekeeper_install_path"
export LD_LIBRARY_PATH="$corekeeper_install_path/linux64/"
SERVER_LD_PRELOAD=""
corekeeper_server="$corekeeper_install_path/_launch.sh"



main() {
    wait_for_server_download
    run_server
}


wait_for_server_download() {
    while :; do
        if [ -f "$corekeeper_server" ]; then
            break
        else
            debug "Corekeeper Server is not yet downloaded - waiting"
            sleep 7
        fi
    done
}


# This runs after server start and waits for the
# config files to either exist or for the server
# to create them so their access permissions can
# be adjusted to the proper values.
ensure_permissions_after_start() {
    while :; do
        if [ -f "/config/adminlist.txt" ]; then
            ensure_permissions
            break
        else
            sleep 4
        fi
    done
}


wait_for_server_listening() {
    pre_server_listening_hook
    while :; do
        if server_is_listening; then
            update_server_status running
            debug "Server is now listening on UDP port $SERVER_PORT"
            post_server_listening_hook
            break
        else
            debug "Waiting for server to listen on UDP port $SERVER_PORT"
            sleep 5
        fi
    done
}


run_server() {
    pre_server_run_hook
    info "Running Corekeeper Server"
    debug "Server config is name: $SERVER_NAME, port: $SERVER_PORT/udp, world: $WORLD_NAME, public: $SERVER_PUBLIC, mod: $mod_name"
    update_server_status starting

    chmod +x "$corekeeper_server"
    # shellcheck disable=SC2086
    LD_PRELOAD=$SERVER_LD_PRELOAD "$corekeeper_server" -nographics -batchmode -name "$SERVER_NAME" -port "$SERVER_PORT" -world "$WORLD_NAME" -public "$SERVER_PUBLIC" "${password_args[@]}" $SERVER_ARGS > >(filter) 2>&1 &
    corekeeper_server_pid=$!
    unset LD_LIBRARY_PATH
    unset LD_PRELOAD
    echo $corekeeper_server_pid > "$corekeeper_server_pidfile"

    ensure_permissions_after_start &
    permissions_wait_pid=$!
    wait_for_server_listening &
    wait_for_server_listening_pid=$!

    wait $corekeeper_server_pid
    debug "Corekeeper server with PID $corekeeper_server_pid stopped"
    update_server_status stopped
    post_server_run_hook

    cleanup
    post_server_shutdown_hook
    info "Shutdown complete"
    exit 0
}


cleanup() {
    if [ -n "${permissions_wait_pid:-}" ] && [ -d "/proc/$permissions_wait_pid" ]; then
        kill -TERM $permissions_wait_pid
    fi
    if [ -n "${wait_for_server_listening_pid:-}" ] && [ -d "/proc/$wait_for_server_listening_pid" ]; then
        kill -TERM $wait_for_server_listening_pid
    fi
    clear_lock "$corekeeper_server_pidfile"
}


# This function gets the servers stdout/stderr
# output piped into. It allows for filtering
# of unwanted debug log messages.
filter() {
    unset LD_LIBRARY_PATH
    unset LD_PRELOAD
    "$cmd_corekeeper_logfilter" -logtostderr -v "$COREKEEPER_LOG_FILTER_VERBOSE"
}


pre_server_run_hook() {
    if [ -n "$PRE_SERVER_RUN_HOOK" ]; then
        info "Running pre server run hook: $PRE_SERVER_RUN_HOOK"
        eval "$PRE_SERVER_RUN_HOOK"
    fi
}


post_server_run_hook() {
    if [ -n "$POST_SERVER_RUN_HOOK" ]; then
        info "Running post server run hook: $POST_SERVER_RUN_HOOK"
        eval "$POST_SERVER_RUN_HOOK"
    fi
}

pre_server_listening_hook() {
     if [ -n "$PRE_SERVER_LISTENING_HOOK" ]; then
        info "Running pre server listening hook: $PRE_SERVER_LISTENING_HOOK"
        eval "$PRE_SERVER_LISTENING_HOOK"
    fi
}

post_server_listening_hook() {
    if [ -n "$POST_SERVER_LISTENING_HOOK" ]; then
        info "Running post server listening hook: $POST_SERVER_LISTENING_HOOK"
        eval "$POST_SERVER_LISTENING_HOOK"
    fi
}


shutdown() {
    debug "Received signal to shut down corekeeper-server"
    update_server_status stopping
    if [ $corekeeper_server_pid -eq -1 ]; then
        debug "Corekeeper server is not running yet - aborting startup"
        update_server_status stopped
        exit
    fi
    pre_server_shutdown_hook
    info "Shutting down Corekeeper server with PID $corekeeper_server_pid"
    kill -INT $corekeeper_server_pid
    shutdown_timeout=$(($(date +%s)+timeout))
    while [ -d "/proc/$corekeeper_server_pid" ]; do
        if [ "$(date +%s)" -gt $shutdown_timeout ]; then
            shutdown_timeout=$(($(date +%s)+timeout))
            warn "Timeout while waiting for server to shut down - sending SIG$kill_signal to PID $corekeeper_server_pid"
            kill -$kill_signal $corekeeper_server_pid
            case "$kill_signal" in
                INT)
                    kill_signal=TERM
                    ;;
                *)
                    kill_signal=KILL
            esac
        fi
        debug "Waiting for Corekeeper Server with PID $corekeeper_server_pid to shut down"
        sleep 6
    done
}


pre_server_shutdown_hook() {
    if [ -n "$PRE_SERVER_SHUTDOWN_HOOK" ]; then
        info "Running pre server shutdown hook: $PRE_SERVER_SHUTDOWN_HOOK"
        eval "$PRE_SERVER_SHUTDOWN_HOOK"
    fi
}


post_server_shutdown_hook() {
    if [ -n "$POST_SERVER_SHUTDOWN_HOOK" ]; then
        info "Running post server shutdown hook: $POST_SERVER_SHUTDOWN_HOOK"
        eval "$POST_SERVER_SHUTDOWN_HOOK"
    fi
}


trap shutdown SIGINT SIGTERM
main
