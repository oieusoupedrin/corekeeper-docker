#!/bin/bash
# corekeeper-updater runs on startup and
# periodically checks for server updates.
# It is also responsible for (re)starting
# the corekeeper-server service.

# Include defaults
. /usr/local/etc/corekeeper/defaults
. /usr/local/etc/corekeeper/common

debug "Running Corekeeper Server updater as user $USER uid $UID"
cd /opt/steamcmd || fatal "Could not cd /opt/steamcmd"
pidfile=$corekeeper_updater_pidfile
next_update=$(date +%s)
run=true


main() {
    if (set -o noclobber; echo $$ > "$pidfile") 2> /dev/null; then
        trap update_now SIGHUP
        trap shutdown SIGINT SIGTERM
        trap 'error_handler $? $LINENO $BASH_LINENO "$BASH_COMMAND" $(printf "::%s" ${FUNCNAME[@]}); trap - ERR' ERR
        while [ $run = true ]; do
            ensure_permissions
            verify_kernel
            verify_cpu_mhz
            verify_memory
            verify_storage
            update
            check_server_restart
            next_update=$(($(date +%s)+UPDATE_INTERVAL))
            while [ $run = true ] && [ "$(date +%s)" -lt $next_update ]; do
                sleep 9
            done
        done
    else
        info "Found existing PID file - checking process"
        check_lock $pidfile
    fi
}


update() {
    local logfile
    if ! is_idle; then
        return
    fi
    pre_update_check_hook
    logfile="$(mktemp)"
    info "Downloading/updating/validating corekeeper server from Steam"
    if ! download_corekeeper; then
        if [ -f "$corekeeper_download_path/_launch.sh" ]; then
            error "Failed to update corekeeper server from Steam - however an existing version was found locally - using it"
        else
            error "Failed to download corekeeper server from Steam - retrying later - check your networking and volume access permissions"
            return
        fi
    fi
    rsync -a --itemize-changes --delete --exclude server_exit.drp --exclude steamapps "$corekeeper_download_path/" "$corekeeper_install_path" | tee "$logfile"
    if grep '^[*>]' "$logfile" > /dev/null 2>&1; then
        info "corekeeper Server was updated - restarting"
        if ! check_mods updated; then
            return
        fi
        write_restart_file updated
    else
        info "corekeeper Server is already the latest version"
        if ! check_mods uptodate; then
            return
        fi
        if [ "$just_started" = true ]; then
            write_restart_file just_started
        fi
    fi
    just_started=false
    rm -f "$logfile"
    post_update_check_hook
}

download_corekeeper() {
    # Kill any hung steamcmd processes
    pkill -TERM steamcmd || true
    sleep 1
    pkill -KILL steamcmd || true
    # shellcheck disable=SC2086
    /opt/steamcmd/steamcmd.sh +force_install_dir "$corekeeper_download_path" +login anonymous +app_update 1963720 $STEAMCMD_ARGS +quit
}


# This works around the `Unable to determine CPU Frequency. Try defining CPU_MHZ.` steamcmd issue (#184).
verify_cpu_mhz() {
    local float_regex
    local cpu_mhz
    float_regex="^([0-9]+\\.?[0-9]*)\$"
    cpu_mhz=$(grep "^cpu MHz" /proc/cpuinfo | head -1 | cut -d : -f 2 | xargs)
    if [ -n "$cpu_mhz" ] && [[ "$cpu_mhz" =~ $float_regex ]] && [ "${cpu_mhz%.*}" -gt 0 ]; then
        debug "Found CPU with $cpu_mhz MHz"
        unset CPU_MHZ
    else
        debug "Unable to determine CPU Frequency - setting a default of 1.5 GHz so steamcmd won't complain"
        export CPU_MHZ="1500.000"
    fi
}


verify_memory() {
    local mem_info
    local mem_total
    local mem_min=4000000
    mem_info=$(awk '
        BEGIN {
            total=0
            free=0
            available=0
        }
        {
            if($1 ~ /^MemTotal/)
                total=$2
            else if($1 ~ /^MemFree/)
                free=$2
            else if($1 ~ /^MemAvailable/)
                available=$2
        }
        END {
            print total"/"free"/"available
        }
    ' /proc/meminfo)
    debug "Memory total/free/available: $mem_info"
    mem_total=${mem_info//\/*}
    if [ "$mem_total" -lt $mem_min ]; then
        mem_total=$(iec_size_format "$((mem_total*1024))")
        error "$mem_total is not enough memory"
    fi
}


verify_storage() {
    debug "Storage configuration:"
    df -h | grep -v -E "^(tmpfs|shm)" | grep -v -E "(/sys/|/etc/|/run/)"
    grep -v -E "^(proc|tmpfs|devpts|shm|mqueue|sysfs)" /etc/mtab | grep -v -E "(/sys/|/etc/|/run/)"
}


verify_kernel() {
    debug "Kernel: $(uname -a)"
}


check_server_restart() {
    local mode
    # The control file $corekeeper_restartfile is either created
    # by update() if corekeeper is being installed for the first
    # time or has been updated, or by corekeeper-plus-updater if
    # a new version of the mod has been downloaded.
    if [ -f "$corekeeper_restartfile" ]; then
        mode=$(< "$corekeeper_restartfile")
        rm -f "$corekeeper_restartfile"

        case "$mode" in
                start)
                    if server_is_running; then
                        debug "corekeeper server is already running - no need to start it"
                        return
                    fi
                    ;;
                restart)
                    if ! server_is_running; then
                        mode=start
                    fi
                    ;;
                *)
                    mode=restart
        esac

        pre_hook "$mode"
        supervisorctl "$mode" corekeeper-server
        post_hook "$mode"
    fi
}


is_idle() {
    if [ "$UPDATE_IF_IDLE" = true ]; then
        if [ "$just_started" = true ] && ! server_is_running; then
            debug "corekeeper updater was just started - skipping connected players check"
            return 0
        fi
        if server_is_idle; then
            debug "No players connected to corekeeper server"
            return 0
        else
            debug "Players connected to corekeeper server - skipping update check"
            return 1
        fi

    fi
    return 0
}


pre_hook() {
    local mode
    mode=$1
    if [ "$mode" = restart ] && [ -n "$PRE_RESTART_HOOK" ]; then
        info "Running pre restart hook: $PRE_RESTART_HOOK"
        eval "$PRE_RESTART_HOOK"
    elif [ "$mode" = start ] && [ -n "$PRE_START_HOOK" ]; then
        info "Running pre start hook: $PRE_START_HOOK"
        eval "$PRE_START_HOOK"
    fi
}


post_hook() {
    local mode
    mode=$1
    if [ "$mode" = restart ] && [ -n "$POST_RESTART_HOOK" ]; then
        info "Running post restart hook: $POST_RESTART_HOOK"
        eval "$POST_RESTART_HOOK"
    elif [ "$mode" = start ] && [ -n "$POST_START_HOOK" ]; then
        info "Running post start hook: $POST_START_HOOK"
        eval "$POST_START_HOOK"
    fi
}


pre_update_check_hook() {
    if [ -n "$PRE_UPDATE_CHECK_HOOK" ]; then
        info "Running pre update check hook: $PRE_UPDATE_CHECK_HOOK"
        eval "$PRE_UPDATE_CHECK_HOOK"
    fi
}


post_update_check_hook() {
    if [ -n "$POST_UPDATE_CHECK_HOOK" ]; then
        info "Running post update check hook: $POST_UPDATE_CHECK_HOOK"
        eval "$POST_UPDATE_CHECK_HOOK"
    fi
}


# This is a signal handler registered to SIGHUP
update_now() {
    debug "Received signal to check for update"
    next_update=0
}


shutdown() {
    debug "Received signal to shut down corekeeper-updater"
    clear_lock "$pidfile"
    run=false
}


main
