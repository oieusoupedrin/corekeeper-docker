#!/bin/bash
# trap SIGUSR1 as it is being used to check
# for process aliveness when an existing
# pidfile is found
trap ':' USR1
just_started=${just_started:-true}

# We are creating the following directory structure
# /opt/corekeeper/
#         |___/dl/            <= downloads happen in here
#         |     |___/server/  <= vanilla server download
#         |___/server/        <= vanilla server installation
#
corekeeper_download_path=/opt/corekeeper/dl/server    # corekeeper server download directory
corekeeper_install_path=/opt/corekeeper/server        # corekeeper server installation directory
corekeeper_restartfile="/tmp/corekeeper.restart"      # Signaling file created by corekeeper-updater
                                                # or corekeeper-plus-updater that describes
                                                # if and how to restart the server


# Collection of PID files
corekeeper_server_pidfile=/var/run/corekeeper/corekeeper-server.pid
corekeeper_updater_pidfile=/var/run/corekeeper/corekeeper-updater.pid
corekeeper_backup_pidfile=/var/run/corekeeper/corekeeper-backup.pid

# Supervisor config files
supervisor_http_server_conf=/usr/local/etc/supervisor/conf.d/http_server.conf

# Status httpd config files
status_http_server_conf=/usr/local/etc/supervisor/conf.d/status_http_server.conf
status_http_server_updater_conf=/usr/local/etc/supervisor/conf.d/status_http_server_updater.conf

# Commands
cmd_corekeeper_status=/usr/local/bin/corekeeper-status
cmd_corekeeper_is_idle=/usr/local/bin/corekeeper-is-idle
cmd_supervisorctl=/usr/local/bin/supervisorctl

# Syslog supervisor config file
supervisor_syslog_conf=/usr/local/etc/supervisor/conf.d/syslog.conf


# File containing the git commit shasum this image was build with
git_commit_file=/usr/local/etc/git-commit.HEAD

# Worlds directories
old_worlds_dir="/config/worlds"
worlds_dir="/config/worlds"

# log levels
debug=50
info=40
warn=30
error=20
critical=10
fatal=5
log_level=${log_level:-$debug}


debug()    { logstd $debug    "DEBUG - [$$] - $*"; }
info()     { logstd $info     "INFO - $*"; }
warn()     { logstd $warn     "WARN - $*"; }
error()    { logerr $error    "ERROR - $*"; }
critical() { logerr $critical "CRITIAL - $*"; }
fatal()    { logerr $fatal    "FATAL - $*"; exit 1; }


logstd() {
    local log_at_level
    log_at_level="$1"; shift
    printline "$log_at_level" "$*"
}


logerr() {
    local log_at_level
    log_at_level="$1"; shift
    printline "$log_at_level" "$*" >&2
}


printline() {
    local log_at_level
    local log_data
    log_at_level="$1"; shift
    log_data="$*"

    if [ "$log_at_level" -le "$log_level" ]; then
        echo "$log_data"
    fi
}


ensure_permissions() {
    local restore_errexit=false
    if [ -o errexit ]; then
        restore_errexit=true
        set +e
    fi
    chmod "$CONFIG_DIRECTORY_PERMISSIONS" /config
    chmod -f "$CONFIG_FILE_PERMISSIONS" /config/*.txt
    # Legacy worlds directory
    if [ -d "$old_worlds_dir" ]; then
        chmod "$WORLDS_DIRECTORY_PERMISSIONS" "$old_worlds_dir"
        chmod "$WORLDS_FILE_PERMISSIONS" "${old_worlds_dir}/"*
    fi
    if [ -d "$worlds_dir" ]; then
        chmod "$WORLDS_DIRECTORY_PERMISSIONS" "$worlds_dir"
        chmod "$WORLDS_FILE_PERMISSIONS" "${worlds_dir}/"*
    fi
    
    if [ "$restore_errexit" = true ]; then
        set -e
    fi
}


_udp_datagram_count() {
    local datagram_count
    datagram_count="$(nstat | awk '/UdpInDatagrams/{print $2}' | tr -d ' ')"
    echo "${datagram_count:-0}"
}


server_is_idle() {
    if [ "$SERVER_PUBLIC" = 1 ]; then
        "$cmd_corekeeper_status" > /dev/null 2>&1
    else
        # Throw away datagram statistics since last run
        _udp_datagram_count &>/dev/null
        # Wait to track datagrams over window
        sleep "$IDLE_DATAGRAM_WINDOW"
        if [ "$(_udp_datagram_count)" -gt "$IDLE_DATAGRAM_MAX_COUNT" ]; then
            return 1
        else
            return 0
        fi
    fi
}


server_is_running() {
    test "$(supervisorctl status corekeeper-server | awk '{print $2}')" = RUNNING
}


server_is_listening() {
    awk -v server_port="$SERVER_PORT" '
        BEGIN {
            exit_code = 1
        }
        {
            if ($1 ~ /^[0-9]/) {
                split($2, local_bind, ":")
                listening_port = sprintf("%d", "0x" local_bind[2])
                if (listening_port == server_port) {
                    exit_code = 0
                    exit
                }
            }
        }
        END {
            exit exit_code
        }
    ' /proc/net/udp*
}


check_lock() {
    local pidfile
    local predecessor_pid
    local numre
    pidfile=$1
    predecessor_pid=$(<"$pidfile")
    numre='^[0-9]+$'
    if [[ "$predecessor_pid" =~ $numre ]] ; then
        debug "Sending SIGUSR1 to PID $predecessor_pid"
        if kill -USR1 "$predecessor_pid" &> /dev/null; then
            fatal "Process with PID $predecessor_pid already running - exiting"
        else
            info "Removing stale PID file and starting run"
            clear_lock_and_run "$pidfile"
        fi
    else
        warn "Predecessor PID is corrupt - clearing lock and running"
        clear_lock_and_run "$pidfile"
    fi
}


clear_lock_and_run() {
    local pidfile
    pidfile=$1
    clear_lock "$pidfile"
    main
}


clear_lock() {
    local pidfile
    pidfile=$1
    info "Releasing PID file $pidfile"
    rm -f "$1"
}


error_handler() {
    local ec
    local line_no
    local func_call_line
    local command
    local stack
    ec=$1
    line_no=$2
    func_call_line=$3
    command="$4"
    stack="$5"
    error "Error in line $line_no command '$command' exited with code $ec in $stack called in line $func_call_line"
    return "$ec"
}

write_restart_file() {
    local mode
    local reason
    reason=$1
    if [ "$just_started" = true ] && [ "$reason" = just_started ]; then
        mode="start"
    else
        mode="restart"
    fi
    if [ ! -f "$corekeeper_restartfile" ]; then
        debug "Writing file to $mode corekeeper server"
        echo "$mode" > "$corekeeper_restartfile"
    fi
}


update_server_status() {
    local status
    status=$1
    echo "$status" > "$SERVER_STATUS_FILE"
}


write_bannedlist() {
    write_serverlist banned "$BANNEDLIST_IDS"
}


write_adminlist() {
    write_serverlist admin "$ADMINLIST_IDS"
}


write_permittedlist() {
    write_serverlist permitted "$PERMITTEDLIST_IDS"
}


write_serverlist() {
    local type
    local id_list
    local list_file
    type=$1
    id_list=$2
    list_file="/config/${type}list.txt"

    if [ -n "$id_list" ]; then
        debug "Writing $list_file"
        # Retain original file comment, including weird double space
        echo "// List $type players ID  ONE per line" > "$list_file"
        # shellcheck disable=SC2001
        echo "$id_list" | sed -e "s/ \\+/\\n/g" >> "$list_file"
    fi
}


extract_archive() {
    local archive_path="$1"
    local archive_file="$2"
    cd "$archive_path" || fatal "Could not cd $archive_path"
    debug "Extracting downloaded ZIP archive"
    rm -rf extracted
    mkdir -p extracted
    unzip -d extracted/ "$archive_file"
}


iec_size_format() {
    local byte_size=$1
    local use_bc=false
    local float_regex="^([0-9]+\\.?[0-9]*)\$"

    if [ -z "$byte_size" ] || ! [[ "$byte_size" =~ $float_regex ]]; then
        error "Input $byte_size is no valid float"
        return 1
    fi
    if command -v bc > /dev/null 2>&1; then
        use_bc=true
    fi
    for unit in B KiB MiB GiB TiB PiB EiB ZiB; do
        if [ "${byte_size%.*}" -lt 1024 ]; then
            printf "%.2f %s\\n" "$byte_size" "$unit"
            return
        fi
        if [ "$use_bc" = true ]; then
            byte_size=$(echo "$byte_size/1024" | bc -l)
        else
            byte_size=$((byte_size/1024))
        fi
    done
    printf "%.2f YiB\\n" $byte_size
}
